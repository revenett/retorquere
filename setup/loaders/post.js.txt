$patch$(Zotero.Items, "merge", original => {
  console.log('enter' + ' ' + '<anonymous:81>' + '(' + JSON.stringify(Array.from(arguments)) + ')');

  try {
    {
      try {
        const merge = {
          citationKey: Preference.extraMergeCitekeys,
          tex: Preference.extraMergeTeX,
          kv: Preference.extraMergeCSL
        };
        if (merge.citationKey || merge.tex || merge.kv) {
          const extra = Extra.get(item.getField("extra"), "zotero", { citationKey: merge.citationKey, aliases: merge.citationKey, tex: merge.tex, kv: merge.kv });
          if (!extra.extraFields.citationKey) {
            const pinned = Zotero.BetterBibTeX.KeyManager.keys.findOne($and({ itemID: item.id }));
            if (pinned.pinned)
              extra.extraFields.citationKey = pinned.citekey;
          }
          if (merge.citationKey) {
            const otherIDs = otherItems.map(i => {
              console.log('enter' + ' ' + '<anonymous:96>' + '(' + JSON.stringify(Array.from(arguments)) + ')');

              try {} catch (trace$error) {
                console.log('error' + ' ' + '<anonymous:96>' + ': ' + trace$error.message);
                throw trace$error;
              } finally {
                console.log('exit' + ' ' + '<anonymous:96>');
              }
            });
            extra.extraFields.aliases = [...extra.extraFields.aliases, ...Zotero.BetterBibTeX.KeyManager.keys.find($and({ itemID: { $in: otherIDs } })).map(i => {
              console.log('enter' + ' ' + '<anonymous:97>' + '(' + JSON.stringify(Array.from(arguments)) + ')');

              try {} catch (trace$error) {
                console.log('error' + ' ' + '<anonymous:97>' + ': ' + trace$error.message);
                throw trace$error;
              } finally {
                console.log('exit' + ' ' + '<anonymous:97>');
              }
            })];
          }
          for (const i of otherItems) {
            const otherExtra = Extra.get(i.getField("extra"), "zotero", { citationKey: merge.citationKey, aliases: merge.citationKey, tex: merge.tex, kv: merge.kv });
            if (merge.citationKey) {
              extra.extraFields.aliases = [...extra.extraFields.aliases, ...otherExtra.extraFields.aliases];
              if (otherExtra.extraFields.citationKey)
                extra.extraFields.aliases.push(otherExtra.extraFields.citationKey);
            }
            if (merge.tex) {
              for (const [name, value] of Object.entries(otherExtra.extraFields.tex)) {
                if (!extra.extraFields.tex[name])
                  extra.extraFields.tex[name] = value;
              }
            }
            if (merge.kv) {
              for (const [name, value] of Object.entries(otherExtra.extraFields.kv)) {
                const existing = extra.extraFields.kv[name];
                if (!existing) {
                  extra.extraFields.kv[name] = value;
                } else if (Array.isArray(existing) && Array.isArray(value)) {
                  for (const creator in value) {
                    if (!existing.includes(creator))
                      existing.push(creator);
                  }
                }
              }
            }
          }
          if (merge.citationKey) {
            const citekey = Zotero.BetterBibTeX.KeyManager.keys.findOne($and({ itemID: item.id })).citekey;
            extra.extraFields.aliases = extra.extraFields.aliases.filter(alias => {
              console.log('enter' + ' ' + '<anonymous:128>' + '(' + JSON.stringify(Array.from(arguments)) + ')');

              try {} catch (trace$error) {
                console.log('error' + ' ' + '<anonymous:128>' + ': ' + trace$error.message);
                throw trace$error;
              } finally {
                console.log('exit' + ' ' + '<anonymous:128>');
              }
            });
          }
          item.setField("extra", Extra.set(extra.extra, {
            citationKey: merge.citationKey ? extra.extraFields.citationKey : void 0,
            aliases: merge.citationKey ? extra.extraFields.aliases : void 0,
            tex: merge.tex ? extra.extraFields.tex : void 0,
            kv: merge.kv ? extra.extraFields.kv : void 0
          }));
        }
      } catch (err) {
        log.error("Zotero.Items.merge:", err);
      }
      return await original.apply(this, arguments);
    }
  } catch (trace$error) {
    console.log('error' + ' ' + '<anonymous:81>' + ': ' + trace$error.message);
    throw trace$error;
  } finally {
    console.log('exit' + ' ' + '<anonymous:81>');
  }
});
