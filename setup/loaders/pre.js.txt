$patch$(Zotero.Items, "merge", (original) => async function Zotero_Items_merge(item, otherItems) {
  try {
    const merge = {
      citationKey: Preference.extraMergeCitekeys,
      tex: Preference.extraMergeTeX,
      kv: Preference.extraMergeCSL
    };
    if (merge.citationKey || merge.tex || merge.kv) {
      const extra = Extra.get(item.getField("extra"), "zotero", { citationKey: merge.citationKey, aliases: merge.citationKey, tex: merge.tex, kv: merge.kv });
      if (!extra.extraFields.citationKey) {
        const pinned = Zotero.BetterBibTeX.KeyManager.keys.findOne($and({ itemID: item.id }));
        if (pinned.pinned)
          extra.extraFields.citationKey = pinned.citekey;
      }
      if (merge.citationKey) {
        const otherIDs = otherItems.map((i) => i.id);
        extra.extraFields.aliases = [...extra.extraFields.aliases, ...Zotero.BetterBibTeX.KeyManager.keys.find($and({ itemID: { $in: otherIDs } })).map((i) => i.citekey)];
      }
      for (const i of otherItems) {
        const otherExtra = Extra.get(i.getField("extra"), "zotero", { citationKey: merge.citationKey, aliases: merge.citationKey, tex: merge.tex, kv: merge.kv });
        if (merge.citationKey) {
          extra.extraFields.aliases = [...extra.extraFields.aliases, ...otherExtra.extraFields.aliases];
          if (otherExtra.extraFields.citationKey)
            extra.extraFields.aliases.push(otherExtra.extraFields.citationKey);
        }
        if (merge.tex) {
          for (const [name, value] of Object.entries(otherExtra.extraFields.tex)) {
            if (!extra.extraFields.tex[name])
              extra.extraFields.tex[name] = value;
          }
        }
        if (merge.kv) {
          for (const [name, value] of Object.entries(otherExtra.extraFields.kv)) {
            const existing = extra.extraFields.kv[name];
            if (!existing) {
              extra.extraFields.kv[name] = value;
            } else if (Array.isArray(existing) && Array.isArray(value)) {
              for (const creator in value) {
                if (!existing.includes(creator))
                  existing.push(creator);
              }
            }
          }
        }
      }
      if (merge.citationKey) {
        const citekey = Zotero.BetterBibTeX.KeyManager.keys.findOne($and({ itemID: item.id })).citekey;
        extra.extraFields.aliases = extra.extraFields.aliases.filter((alias) => alias !== citekey);
      }
      item.setField("extra", Extra.set(extra.extra, {
        citationKey: merge.citationKey ? extra.extraFields.citationKey : void 0,
        aliases: merge.citationKey ? extra.extraFields.aliases : void 0,
        tex: merge.tex ? extra.extraFields.tex : void 0,
        kv: merge.kv ? extra.extraFields.kv : void 0
      }));
    }
  } catch (err) {
    log.error("Zotero.Items.merge:", err);
  }
  return await original.apply(this, arguments);
});
