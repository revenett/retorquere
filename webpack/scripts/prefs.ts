import fs = require('fs')
import parseXML = require('@rgrove/parse-xml')
import dedent = require('dedent-js')
import path = require('path')

class DocFinder {
  private strings: { [key: string]: string }
  private tab: number
  private tabs: string[]
  private preference: string
  private preferences: {
    [key: string]: {
      id: string
      type: string
      preference: string
      tab?: string
      label?: string
      description?: string
      default?: any,
      options?: { [key: string]: string },
    }
  }
  private header: string
  private errors: number
  private defaults: { [key: string]: any }

  constructor() {
    this.strings = {}
    const dtd = fs.readFileSync('locale/en-US/zotero-better-bibtex.dtd', 'utf8')
    dtd.replace(/<!ENTITY\s+([^\s]+)\s+"([^"]+)"\s*/g, (decl, entity, str) => { this.strings[`&${entity};`] = str; return '' })

    this.preferences = {}
    this.tabs = []
    this.tab = -1
    this.errors = 0
    this.defaults = {
      debug: false,
      rawLaTag: '#LaTeX',
      testing: false,
    }

    const prefsPane = parseXML(fs.readFileSync('content/Preferences.xul', 'utf8'), {
      resolveUndefinedEntity: entity => this.strings[entity] || entity,
      preserveComments: true,
    })

    this.walk(prefsPane)

    for (const pref of Object.values(this.preferences)) {
      this.defaults[pref.preference.replace(/.*\./, '')] = pref.default

      if (pref.label) pref.label = pref.label.trim()
      if (pref.tab && !pref.label) this.report(`${pref.preference} has no label`)

      if (pref.description) pref.description = pref.description.trim()
      if (!pref.description) this.report(`${pref.preference} has no description`)
      if (!pref.tab && pref.id) this.report(`${pref.preference} should be hidden`)

      if (pref.options && pref.options[pref.default]) {
        pref.default = pref.options[pref.default]
      } else if (typeof pref.default === 'boolean') {
        pref.default = pref.default ? 'on' : 'off'
      } else {
        pref.default = JSON.stringify(pref.default)
      }
    }

    if (this.errors) process.exit(1)

    fs.writeFileSync(path.join(__dirname, '../../gen/preferences.json'), JSON.stringify(this.defaults, null, 2))

    const docs = path.join(__dirname, '../../wiki/Configuration.md')
    if (fs.existsSync(docs)) {
      const md = [
        dedent(`
          <!-- DO NOT EDIT THIS FILE ON THE GITHUB WIKI
          This page is generated automatically from comments in
          https://github.com/retorquere/zotero-better-bibtex/blob/master/content/Preferences.xul .
          Any edits made directly in this file will be overwritten the next time it is generated.
          -->
        `).trim(),
        this.header,
      ]

      for (const tab of this.tabs) {
        md.push(`## ${tab}`)
        for (const pref of Object.values(this.preferences)) {
          if (pref.tab !== tab) continue
          md.push(`### ${pref.label}`)

          md.push(`default: \`${pref.default}\``)
          md.push(pref.description)

          if (Object.keys(pref.options || {}).length) {
            md.push('Options:\n' + Object.values(pref.options).map(option => `* ${option}`).join('\n'))
          }
        }
      }

      md.push('## Hidden preferences')
      const prefix = 'extensions.zotero.translators.better-bibtex.'
      md.push(dedent(`
        The following settings are not exposed in the UI, but can be found under \`Preferences\`/\`Advanced\`/\`Config editor\`.

        All are prefixed with \`${prefix}\` in the table you will find there
      `))
      for (const pref of Object.values(this.preferences)) {
        if (pref.tab) continue
        md.push(`### ${pref.preference.replace(prefix, '')}`)
        md.push(`default: \`${pref.default}\``)
        md.push(pref.description)
      }

      fs.writeFileSync(docs, md.join('\n\n'))
    }
  }

  private walk(node) {
    let label, pref, type, dflt

    switch (node.type) {
      case 'document':
      case 'text':
        break

      case 'comment':
        if (node.content[0] === '!') {
          if (this.tab !== -1) throw new Error('Doc block outside the prefs section')

          const text = dedent(node.content.substring(1))
          if (this.preference) {
            if (this.preferences[this.preference].description) throw new Error(`Duplicate description for ${this.preference}`)
            this.preferences[this.preference].description = text
          } else {
            if (this.header) throw new Error(`Duplicate header block ${text}`)
            this.header = text
          }
        }
        break

      case 'element':
        switch (node.name) {
          case 'preference':
            this.preference = node.attributes.id || `#${node.attributes.name}`
            type = ({bool: 'boolean', int: 'number'}[node.attributes.type]) || node.attributes.type
            if (typeof node.attributes.default === 'undefined') throw new Error(`No default value for ${this.preference}`)
            switch (type) {
              case 'boolean':
                switch (node.attributes.default) {
                  case 'true':
                    dflt = true
                    break
                  case 'false':
                    dflt = false
                    break
                  default:
                    throw new Error(`Unexpected boolean value ${node.attributes.default} for ${this.preference}`)
                }
                break

              case 'number':
                dflt = parseInt(node.attributes.default)
                if (isNaN(dflt)) throw new Error(`Unexpected int value ${node.attributes.default} for ${this.preference}`)
                break

              case 'string':
                dflt = node.attributes.default
                break

              default:
                throw new Error(`Unexpected ${type} value ${node.attributes.default} for ${this.preference}`)
            }

            this.preferences[this.preference] = {
              id: node.attributes.id,
              type,
              preference: node.attributes.name,
              default: dflt,
            }

            break

          case 'tab':
            this.tabs.push(node.attributes.label)
            break

          case 'tabpanel':
            this.tab++
            break

          default:
            if (pref = node.attributes.preference || node.attributes.forpreference) {
              if (!this.preferences[pref]) throw new Error(`There's an UI element for non-existent preference ${pref}`)

              this.preferences[pref].options = {}
              if (node.name === 'radiogroup') {
                for (const option of node.children.filter(child => child.name === 'radio'))  {
                  this.preferences[pref].options[option.attributes.value] = option.attributes.label.trim()
                }
              }
              if (node.name === 'menulist') {
                const menupopup = node.children.find(child => child.name === 'menupopup')
                for (const option of menupopup.children.filter(child => child.name === 'menuitem'))  {
                  this.preferences[pref].options[option.attributes.value] = option.attributes.label.trim()
                }
              }

              if (node.attributes.label) label = node.attributes.label.trim()
              else if (node.attributes.value) label = node.attributes.value.trim()
              else if (label = node.children.find(child => child.type === 'text')) label = label.text.trim()

              if (label) {
                this.preferences[pref].label = label
                this.preferences[pref].tab = this.tabs[this.tab]
              }
            }
            break
        }
        break

      default:
        throw new Error(node.type + (node.type === 'element' ? `.${node.name}` : ''))
    }

    for (const child of node.children || []) { this.walk(child) }
  }

  private report(msg) {
    console.log(msg) // tslint:disable-line:no-console
    this.errors += 1
  }
}

new DocFinder // tslint:disable-line:no-unused-expression
